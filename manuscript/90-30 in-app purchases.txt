{pagebreak}

## Conceptual Details of In-App Purchases

I didn't hear anything about "in-app purchases" before Apple's App Stores made them popular. When you look close, the underlying principle of performing additional purchases during software runtime goes back a bit longer.

FarmVille launched on Facebook in 2009. That's two years after the iPhones initial public release, so FarmVille predates in-app purchases in the iOS App Store by years. Their microtransactions rely on a similar mechanism. Spend real money to buy in-game currency to spend on speeding up your progress.

Governments begin to push against addictive computer games that support microtransactions. Microtransactions to obtain loot boxes are considered gambling in a couple of countries and already resulted in legal charges against Electronic Arts in recent years. "Addictive computer gaming" is a weird term, when you think about it. Games are designed to be fun and come with rewarding and thus often addictive game-play loops. Apart from being effective time sinks, games sucking your bank account dry appears to be a different phenomenon, one the public is opposed to.
  
Did you know that some of the underlying algorithms of in-game progress not only make players stagnate, but actually _lose_ what they've earned, too? There's [a great talk](https://www.youtube.com/watch?v=us6OPbYtKBM) about this by Puzzle Clubhouse's Jesse Schell at D.I.C.E. SUMMIT 2013. In short, if you continue to play for free, you'll eventually get _worse_ until you buy in-game consumables. That's as sick as it gets. Maybe I'm a romanticist, but any well-crafted software, games included, should aim to make the user's life better in some way, not worse. At least not by design. Tools that delete data from your computer unless you pay the creators are called ransomware for a reason.

The bad standing of microtransactions and free-to-play schemes also diminished the reputation of in-app purchases a bit. In productivity apps, in-app purchases often unlock specific but optional features, and that's hardly a reason for complaints anymore. Freemium business models with IAP's can support developers and be outright beneficial for users. Who would've thought! 

There's no need to dismiss IAP's if you think a freemium pricing model is a good fit for your app. Outside the Mac App Store, we can distribute demo versions or time-based trials easily. You cannot do the same on the App Store; the Store requires your app to stay functional in some way, so freemium became the de facto replacement for trials. If you just transition from the Mac App Store to distributing on your own, you may have to unlearn this bit. Do not replicate the freemium pricing model just because that's what you'd reach for in the App Store. Consider your options, first.

It appears that in non-game applications, purchasing content instead of features is better received by customers, [as Stuart K. Hall's experience indicates](https://stuartkhall.com/posts/an-app-store-experiment-part-3). For his workout app, purchasing content results in a new set of workout videos and instructions. Dark mode or cloud sync would be features. Make sure to read [Part 4 of his series](https://stuartkhall.com/posts/an-app-store-experiment-part-4), where his numbers indicate that users, once hooked, don't even bother picking single options but simply _unlock everything_ instead. In terms of your FastSpring setup, that means you should consider providing a bundle product.

When you do want to do microtransactions or in-app purchases, you can implement these with FastSpring, too, although you need to do a bit more work to make it happen. With the embedded store SDK from Classic Commerce or the HTTP API from Contextual, FastSpring allows you to perform transactions from within your app. The round-trip to your web store might be a bit too inconvenient, and your conversion rate could suffer in consequence, so try to make the experience as simple as possible.

From FastSpring's perspective, in-app purchases are products like your app itself or bundle offers. You have to set them up as separate products, but probably want to hide them from your web storefronts by default -- unless it makes sense to buy them from your website, that is.

Apple's App Stores's support of IAP's is very convenient for developers. The purchases are linked to the customer's Apple ID, and your app can ask the store for details. With FastSpring, you have to roll your own solution. To copy Apple's approach to IAP, this involves instant unlocking of features when purchased within the app, as we explore in [the section about the embedded store SDK](#embeddedstore), and "restoring" past purchases. For example when a user gets a new Mac and installs your app, she'll like to have access to all the IAP's from her old Mac. If you rely on offline activation, you could end up providing one license code per IAP. If you rely on online activation, you will have to provide a user login mechanism and store order information from FastSpring next to your user database. The latter would replicate the online activation of Apple's App Stores, based on a customer's Apple ID.

When you go down the rabbit hole of online activation, think about fallback mechanisms, like serial codes as a secondary means of activation. With the proliferation of subscriptions in App Store apps, one particular complaint stuck with me: sometimes, people don't have 24/7 access to the internet. Sometimes, people actually work on a ship, an actual vessel on the ocean, during a six month polar expedition. And if you happen to develop apps to boost research productivity, you don't want to disable this segment of users. To require an always-on internet connection can work for your target audience, but think twice about how to make this less painful for paying customers. You don't want to penalize customers with an instrument that is supposed to punish software pirates. AAA games pioneered online DRM and still work hard to push the games-as-a-service approach. Blizzard's approach to copy protection of _Warcraft III_, for example, appears very mild in comparison to more modern activation schemes. They require you to set up a Battle.net account and link the _Warcraft III_ serial number to that account. You cannot share the same serial with friends for LAN parties anymore as you'd have during the earlier 2000's. But that's about as punishing as it gets. Offline activation with the serial works, too; you just can't play multiplayer matches. On the upside, you can always download a copy of your games for free from their website when you authenticate with your Battle.net account. Remember the backlash of fans when SimCity 4 required an always-on internet connection, kicked you out of the game when the servers stopped responding, and came with very spotty server service availability. To be fair, Blizzard's servers were overwhelmed with the onslaught of _Diablo III_ players in the beginning, much like _World of Warcraft: Classic_ servers in 2019. You see, even big corporations underestimate how brittle things get when you introduce remote connections. Pro-users who earn their salary from putting your app to use will not be pleased when bad internet reception or your server being down for maintenance prevents the app from launching. Offline activation could come in handy in these cases.

Then again, what kind of pro-app can you develop where in-app consumables play an important role?

All in all, the process of implementing in-app purchases can be implemented in a very similar way to regular purchases. Offline activation can use serial numbers or license codes; online activation boils down to setting a flag in your online user database and authorizing access to features. IAP implementations are riddled with compromises: Ending up having to hand out a dozen license codes per customer when one unlocks every feature in your app is positively weird. Switching to online activation sounds way cooler and is ultimately easier for customers, but then your app ceases to work when your servers go down or their internet reception becomes abysmal. Apparently, you can have both the ease of online activation and the longevity of offline license code activation, but then you have to implement and support both mechanisms in your app.

I like to think that this is a morally sound compromise: Do online activation by default so users only have to authenticate on each device once and have access to all the features they have purchased. Then also offer offline license code activation as a fallback upon request. This ensures longevity of the product way beyond your company's lifetime.

Remember how the CocoaFob licensing template was just a concatenation of product name and licensee name? You can encode arbitrary information in that string to represent purchased features. You can put information about in-app purchases in there, too, or the date of purchase, or anything else, really. 

My suggestion is you encode all the purchased IAP features into a single license code by using a simple bit-mask. For example, if you have 6 IAP's in your app, a bit-mask of `000000` means "only the main app", `111111` means "all IAP's enabled". A single number with the bits `111111` is 63 in decimal. If Jane Doe purchases the app with all additional features, the string I expect to be encoded by CocoaFob into a personalized license code is `"mynewapp,63,Jane Doe"`. Her brother John, who bought the core app only, will get a license code based on the string `"mynewapp,0,John Doe"`. If you add features, the bit-mask grows, and thus the number changes. With that, you do not need to produce one license code per feature, and users don't have to enter 6 license codes to unlock 6 features.

To allow customers to purchase IAP's at any date, and not only during the initial purchase, you will have to store customer records in some kind of database. Without a permanent record, you cannot _add_ features access rights. FastSpring stores order details for your own record, but you cannot access a history of my purchases in your store and compute a license code based on that. You'll have to implement all of this on your server:

- Switch your app's license generator from the built-in CocoaFob to a self-hosted solution as explained in the previous section.
- For every incoming license request, create a user record based on the email if it doesn't exist, or alter an existing record to toggle the flag corresponding to the IAP.
- With the resulting database record you can construct the bit-mask as `$iapBitmask` and change the CocoaFob license template to `"{$productName},{$iapBitmask},{$licenseName}"`.

Here's the data you have access to from a self-hosted license generator request again, when the request is performed by FastSpring:

{linenos=off}
    Array
    (
        [company] => Licensee's Company
        [email] => licensee.email@example.com
        [internalProductName] => mynewapp_featureXYZ
        [name] => LICENSEE NAME
        [quantity] => 1
        [reference] => FASTSPRING_ORDER_REFERENCE_NO
        [subscriptionReference] => FASTSPRING_SUBSCRIPTION_REFERENCE_NO
        [security_request_hash] => xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    )

With `$_REQUEST['email']`, `$_REQUEST['name']`, and `$_REQUEST['internalProductName']` you can achieve everything I just outlined. `internalProductName` would correspond to the in-app purchase product name. To store customer data, a SQLite database will do the job just fine if your host doesn't offer MySQL. The database implementation and computation of the bit-mask is left as an exercise to the reader. If you got this far, this is not much work anymore.

Finally, your app needs to treat the decoded information from license codes differently. The decoding step stays the same since it applies the public key to the license code only. But your `LicenseVerifier` implementation needs to know that the template is different and properly ignore the middle portion, the bit-mask, when it unlocks the base application. Plus you need to write logic to unlock features based on the bit-mask, for example by attaching more information to the `licenseDidChange` notification.
