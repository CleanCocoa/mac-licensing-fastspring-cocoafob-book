{pagebreak}

## Conceptual Details of In-App Purchases

I didn't hear anything about "in-app purchases" before Apple's App Stores made them popular. When you look close, the underlying principle of performing additional purchases during software runtime goes back a bit longer.

FarmVille launched on Facebook in 2009. That's two years after the iPhones initial public release, so FarmVille predates in-app purchases in the iOS App Store by years. Their microtransactions rely on a similar mechanism. Spend real money to buy in-game currency to spend on speeding up your progress.

Governments begin to push against addictive computer games that support microtransactions. Microtransactions to obtain loot boxes are considered gambling in a couple of countries and already resulted in legal charges against Electronic Arts in recent years. "Addictive computer gaming" is a weird term, when you think about it. Games are designed to be fun and come with rewarding and thus often addictive game-play loops. Apart from being effective time sinks, games sucking your bank account dry appears to be a different phenomenon, one the public is opposed to.
  
Did you know that some of the underlying algorithms of in-game progress not only make players stagnate, but actually _lose_ what they've earned, too? There's [a great talk](https://www.youtube.com/watch?v=us6OPbYtKBM) about this by Puzzle Clubhouse's Jesse Schell at D.I.C.E. SUMMIT 2013. In short, if you continue to play for free, you'll eventually get _worse_ until you buy in-game consumables. That's as sick as it gets. Maybe I'm a romanticist, but any well-crafted software, games included, should aim to make the user's life better in some way, not worse. At least not by design. Tools that delete data from your computer unless you pay the creators are called ransomware for a reason.

The bad standing of microtransactions and free-to-play schemes also diminished the reputation of in-app purchases a bit. In productivity apps, in-app purchases often unlock specific but optional features, and that's hardly a reason for complaints anymore. Freemium business models with IAP's can support developers and be outright beneficial for users. Who would've thought! 

There's no need to dismiss IAP's if you think a freemium pricing model is a good fit for your app. Outside the Mac App Store, we can distribute demo versions or time-based trials easily. You cannot do the same on the App Store; the Store requires your app to stay functional in some way, so freemium became the de facto replacement for trials. If you just transition from the Mac App Store to distributing on your own, you may have to unlearn this bit. Do not replicate the freemium pricing model just because that's what you'd reach for in the App Store. Consider your options, first.

It appears that in non-game applications, purchasing content instead of features is better received by customers, [as Stuart K. Hall's experience indicates](https://stuartkhall.com/posts/an-app-store-experiment-part-3). For his workout app, purchasing content results in a new set of workout videos and instructions. Dark mode or cloud sync would be features. Make sure to read [Part 4 of his series](https://stuartkhall.com/posts/an-app-store-experiment-part-4), where his numbers indicate that users, once hooked, don't even bother picking single options but simply _unlock everything_ instead. In terms of your FastSpring setup, that means you should consider providing a bundle product.

When you do want to do microtransactions or in-app purchases, you can implement these with FastSpring, too, although you need to do a bit more work to make it happen. With the embedded store SDK from Classic Commerce or the HTTP API from Contextual, FastSpring allows you to perform transactions from within your app. The round-trip to your web store might be a bit too inconvenient, and your conversion rate could suffer in consequence, so try to make the experience as simple as possible.

From FastSpring's perspective, in-app purchases are products like your app itself or bundle offers. You have to set them up as separate products, but probably want to hide them from your web storefronts by default -- unless it makes sense to buy them from your website, that is.

Apple's App Stores's support of IAP's is very convenient for developers. The purchases are linked to the customer's Apple ID, and your app can ask the store for details. With FastSpring, you have to roll your own solution. To copy Apple's approach to IAP, this involves instant unlocking of features when purchased within the app, as we explore in [the section about the embedded store SDK](#embeddedstore), and "restoring" past purchases. For example when a user gets a new Mac and installs your app, she'll like to have access to all the IAP's from her old Mac. If you rely on offline activation, you could end up providing one license code per IAP. If you rely on online activation, you will have to provide a user login mechanism and store order information from FastSpring next to your user database. The latter would replicate the online activation of Apple's App Stores, based on a customer's Apple ID.

When you go down the rabbit hole of online activation, think about fallback mechanisms, like serial codes as a secondary means of activation. With the proliferation of subscriptions in App Store apps, one particular complaint stuck with me: sometimes, people don't have 24/7 access to the internet. Sometimes, people actually work on a ship, an actual vessel on the ocean, during a six month polar expedition. And if you happen to develop apps to boost research productivity, you don't want to disable this segment of users. To require an always-on internet connection can work for your target audience, but think twice about how to make this less painful for paying customers. You don't want to penalize customers with an instrument that is supposed to punish software pirates. AAA games pioneered online DRM and still work hard to push the games-as-a-service approach. Blizzard's approach to copy protection of _Warcraft III_, for example, appears very mild in comparison to more modern activation schemes. They require you to set up a Battle.net account and link the _Warcraft III_ serial number to that account. You cannot share the same serial with friends for LAN parties anymore as you'd have during the earlier 2000's. But that's about as punishing as it gets. Offline activation with the serial works, too; you just can't play multiplayer matches. On the upside, you can always download a copy of your games for free from their website when you authenticate with your Battle.net account. Remember the backlash of fans when SimCity 4 required an always-on internet connection, kicked you out of the game when the servers stopped responding, and came with very spotty server service availability. To be fair, Blizzard's servers were overwhelmed with the onslaught of _Diablo III_ players in the beginning, much like _World of Warcraft: Classic_ servers in 2019. You see, even big corporations underestimate how brittle things get when you introduce remote connections. Pro-users who earn their salary from putting your app to use will not be pleased when bad internet reception or your server being down for maintenance prevents the app from launching. Offline activation could come in handy in these cases.

Then again, what kind of pro-app can you develop where in-app consumables play an important role?

All in all, the process of implementing in-app purchases can be implemented in a very similar way to regular purchases. Offline activation can use serial numbers or license codes; online activation boils down to setting a flag in your online user database and authorizing access to features. IAP implementations are riddled with compromises: Ending up having to hand out a dozen license codes per customer when one unlocks every feature in your app is positively weird. Switching to online activation sounds way cooler and is ultimately easier for customers, but then your app ceases to work when your servers go down or their internet reception becomes abysmal. Apparently, you can have both the ease of online activation and the longevity of offline license code activation, but then you have to implement and support both mechanisms in your app.

I like to think that this is a morally sound compromise: Do online activation by default so users only have to authenticate on each device once and have access to all the features they have purchased. Then also offer offline license code activation as a fallback upon request. This ensures longevity of the product way beyond your company's lifetime.

Remember how the CocoaFob licensing template was just a combination of product name and licensee name? You can encode arbitrary information in that string to represent purchased features. You can put a bitmask in there, where `111111` unlocks all 6 available IAP features, `100101` unlocks only 3 of 6, and so on. With that, one license code can encode multiple IAP's and you don't need to distribute one code per feature. To figure out which IAP's are available still requires some kind of online record on your side so you can toggle a single flag and generate a license code that takes all the previous purchases into account.

There's no way FastSpring can produce license codes with these information, though. You'll have to implement this on your server.

We're not going through the implementation details. Here's a TL;DR version of the changes you'd have to make to your license generator:

- Switch your app's license generator from the built-in CocoaFob to a self-hosted solution.
- Create a server endpoint, for example by uploading a PHP file to `/license/generator.php` on your web site. Copy the FastSpring authentication code snippet into this server script to enable the generator only for FastSpring-originated callbacks.
- For every incoming license request, create a user record based on the email, or alter an existing record to toggle the IAP's flag.
- Upload the CocoaFob PHP scripts to generate license codes from the GitHub repository: <https://github.com/glebd/cocoafob/tree/master/php>
- With the resulting data from your records represented by a variable like `$featureBitmask`, fill a license template of `"{$productName},{$featureBitmask},{$licenseeName}"`, pass it to CocoaFob, and `echo`/`print` the resulting license code. FastSpring will consider the HTTP response contents to be the license code or license codes, one per line.

This is the data you have access to in the license generator request performed by FastSpring, represented as a PHP variable dump:

{linenos=off}
    Array
    (
        [company] => Licensee's Company
        [email] => licensee.email@example.com
        [internalProductName] => mynewapp_featureXYZ
        [name] => LICENSEE NAME
        [quantity] => 1
        [reference] => FASTSPRING_ORDER_REFERENCE_NO
        [subscriptionReference] => FASTSPRING_SUBSCRIPTION_REFERENCE_NO
        [security_request_hash] => xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    )

With `$_REQUEST['email']`, `name`, and `internalProductName` you can achieve everything I just outlined as soon as you add a persistent storage for purchase details and thus customer feature access. A SQLite database will do the job just fine, and the dreaded server endpoint will turn out to be a PHP script with way less than 100 lines of code, the CocoaFob files not counting. The database implementation and bitmask computation is left as an exercise to the reader.
