## Use an Embedded Web Store for Purchases

![The resulting Embedded Web Store within the app](images/20-110-web-store.png)

If you want to let users buy the app from within the app via the _Embedded Web Store_, you'll have to import FastSpring's SDK.

This is additional work, although not very much. Why would you want to do it?

* It is said that embedded stores increase conversion from trial users to paying customers.
* Buying a license from within the app can immediately unlock it. Your application obtains the license from the embedded store.

D> Philip Goward of Smile, the team behind TextExpander and PDFPen, stressed that buying a license within the app lowers the barrier to buy the app. Smile has lots of years of experience, so we better listen.
D>
D> The most interesting advice he gave me to share with you is this: display the store window on launch, even on first launch. It converts incredibly well.
D> I'll certainly have a look at the effect of this change in my own applications. Keep in mind though that having to click through too many dialog boxes on first launch can just as well ruin the initial user experience.


### Enable the Embedded Store in SpringBoard

(Refer to [the docs][doc] for the most up to date instructions.)

The Embedded Web Store will need a different style. The [FastSpring SDK on GitHub][github] contains a folder called "FsprgEmbeddedStoreStyle". Put the CSS, the XHTML, and the PayPal folder into a Zip file. Alternatively, you can use the prepared Zip from the sample code. We'll need that in a moment.

Log into your SpringBoard. From there, apply the following configurations:

![20 102 Enable Web Store](images/20-102-enable-web-store.png)
![20 103 Create Style](images/20-103-create-style.png)

* _Store Settings_ / _Advanced_: pick "Property List XML" to enable Web Store requests.
* _Styles_: create a new style. Upload the Zip file you just prepared. 
    * Then _Edit Conditions_ of the style and add an "Order Environment Condition" with the value "FS Embedded" so the default store won't change appearance. 
    * _Activate_ the style afterwards.
* _Store Testing_: select "Simulate Embedded" under _Optional Parameters_ and check out the differences. The embedded style looks much cleaner.

![The default FastSpring style to the left, the embedded style to the right.](images/20-104-stores-comparison.png)

Next, add a test user to test purchases during development.

The _Account_ Page is the calculator button to the right in your SpringBoard. There, navigate to _Users_ (in the sidebar). Add a new user with the "Limited API User" role. You'll receive a password via e-mail.

Keep the e-mail you used for the user and its password handy as you'll likely need it often.

Now everything should be ready to roll from FastSpring's side.

[doc]: https://support.fastspring.com/entries/234307-Embedded-Web-Store-SDK
[github]: https://github.com/FastSpring/FsprgEmbeddedStoreMac#how-to-embed-it

### Embed FastSpring Library

You can use CocoaPods or get the source from GitHub:

* CocoaPods: <http://cocoapods.org/?q=fsprgembeddedstoremac>
* GitHub: <https://github.com/FastSpring/FsprgEmbeddedStoreMac#how-to-embed-it>

I use GitHub for the samples to keep the project set-up simple.

From `FsprgEmbeddedStoreMac/FsprgEmbeddedStore/`, add all the files except the "Test" folder to your project. That will be:

* `FsprgEmbeddedStore.h`
* `FsprgEmbeddedStoreController.h`
* `FsprgEmbeddedStoreController.m`
* `FsprgEmbeddedStoreDelegate.h`
* `FsprgOrderDocumentRepresentation.h`
* `FsprgOrderDocumentRepresentation.m`
* `FsprgOrderView.h`
* `FsprgOrderView.m`
* `FsprgStoreParameters.h`
* `FsprgStoreParameters.m`
* `Model/FsprgFileDownload.h`
* `Model/FsprgFileDownload.m`
* `Model/FsprgFulfillment.h`
* `Model/FsprgFulfillment.m`
* `Model/FsprgLicense.h`
* `Model/FsprgLicense.m`
* `Model/FsprgOrder.h`
* `Model/FsprgOrder.m`
* `Model/FsprgOrderItem.h`
* `Model/FsprgOrderItem.m`

Disable ARC for the following files in "Compiler Sources" under the app target's "Build Phases" pane. Add the `-fno-objc-arc` flag to all FastSpring-related `.m` files in the list.

![ARC disabled for the FastSpring files files which cause build errors otherwise.](images/20-101-arc-disabled-fastspring-cocoafob.png)

Now the test target will not find the header files by default, though.

Go to the test target settings and select the "Build Setting" pane. Use the search to get to "User Header Search Paths". In the test target's column, which is probably the second column you can edit, double-click the table cell and drag the `FsprgEmbeddedStore` folder in there (that's the one where we picked the files from).

In the example project setup, this resolves to:

{linenos=off,lang="text"}
    "$(SRCROOT)/../External/FsprgEmbeddedStoreMac/FsprgEmbeddedStore"

Make sure to select "recursive" from the options.

Both the app and test target should build again.

## Implement the Embedded Web Store Protocol

Nearly all of the work will be done in a class which implements `FsprgEmbeddedStoreDelegate`. This protocol has four required methods, only two of which are interesting for most of us:

* `didReceiveOrder(order: FsprgOrder!)`  

    Here, we'll handle automatically unlocking the app after a purchase.
* `viewWithFrame(frame: NSRect, forOrder order: FsprgOrder!) -> NSView!`
    
    Return a custom view to display the order confirmation. This will usually be a thank-you with the license details.
* `didLoadStore(url: NSURL!)`
* `didLoadPage(url: NSURL!, ofType pageType: FsprgPageType)`



### Order Confirmation View

It's cool that FastSpring offers showing a custom view after purchases within the store view. It often doesn't look as good because the underlying web view has a white background by default. But you can make a lot from that.

Keeping things clean, I prefer a custom view subclass:

    public class OrderConfirmationView: NSView {
        @IBOutlet public var licenseCodeTextField: NSTextField!
    
        public func displayLicenseCode(licenseCode: String) {
            licenseCodeTextField.stringValue = licenseCode
        }
    }
    
It's easy to populate its text field:

    func viewWithFrame(frame: NSRect, forOrder order: FsprgOrder!) -> NSView! {
        if let orderConfirmationView = orderConfirmationView,
            license = licenseFromOrder(order) {
            
            orderConfirmationView.displayLicenseCode(license.licenseCode)
            return orderConfirmationView
        }
        
        return nil
    }

The result looks like this:

![Our simple view](images/20-301-thankyou.png)

As I said, it's not very pretty. FastSpring's SDK doesn't use Auto Layout, so things look a little bit off by default.

I prefer to leave this alone, return `nil`, close the store window, and show a custom window in `didReceiveOrder(_:)`. There's no need to use all of FastSpring's hooks.

So let's take a look at the more important `didReceiveOrder(_:)` method.

### Unlock the App After Purchases

In `didReceiveOrder(order: FsprgOrder!)`, you'll be able to obtain all license details from `order`. To unlock the app, we need the license code and the licensee's name.

Because your users could buy a different product, more than a single product, or multiple licenses for the same product, we need to check some parameters.

`order.orderItems` contains `FsprgOrderItem`s. Check the item's `productName` to start with the name of the app. If it matches, you've got a paying customer for this particular application.

`FsprgOrderItem` contains `license() -> FsprgLicense`. We can obtain the licensee's name via its `licenseName()` and the license code via `firstLicenseCode()`. With these values, we can build an instance of our own `License` object. The store's job is finished.

In code, there's a lot of implicit unwrapped optionals to steer around. It looks messier than it actually is.

Let me walk you through the process to explain the array transformations:

    func didReceiveOrder(order: FsprgOrder!) {
        
        // Thanks Obj-C bridging without nullability annotations:
        // implicit unwrapped optionals are not safe
        if !hasValue(order) {
            return
        }
        
        if let license = licenseFromOrder(order) {
            storeDelegate?.store(self, didPurchaseLicense: license)
        }
    }
    
    private func licenseFromOrder(order: FsprgOrder) -> License? {
        if let items = order.orderItems() as? [FsprgOrderItem],
            license = items
                .filter(orderItemIsForThisApp)
                .map(licenseFromOrderItem) // -> [License?]
                .filter(hasValue)          // keep non-nil
                .map({ $0! })              // -> [License]
                .first {
        
            return license
        }
    
        return nil
    }
    
    private func orderItemIsForThisApp(orderItem: FsprgOrderItem) -> Bool {
        let appName = storeInfo.productName
    
        if let productName = orderItem.productName() {
            return productName.hasPrefix(appName)
        }
    
        return false
    }

    private func licenseFromOrderItem(orderItem: FsprgOrderItem) -> License? {
        if let orderLicense = orderItem.license(),
            name = orderLicense.licenseName(),
            licenseCode = orderLicense.firstLicenseCode() {
            
            return License(name: name, licenseCode: licenseCode)
        }
    
        return nil
    }

`orderItems()` returns `[AnyObject]!`; we can try to cast the whole array or enumerate the items and cast each on its own. I think this is cleaner, although less lenient if FastSpring should add objects of a different kind.

`license` will be of the value type `License`. To get there from an `FsprgOrderItem`, I apply quite a few array transformations:

1. Filter all order items for this which are about this app, comparing the `productName` as stated above.
2. From the order items which apply, create a `License` instance using the process explained above. This may fail, so we end up with an array of optionals, `[License?]`, which sucks.
3. Filter all elements in the `[License?]` array so only non-nil values are left.
4. Now it's safe to force-unwrap the remaining optionals to get back an array of licenses, `[License]`.
5. Finally, take the first element (if any) and pass it to the delegate.

![Acorn's very sexy registration confirmation window. It's a good idea to go the extra mile and make this pretty](images/20-300-acorn.png)

The delegate may present a window like Acorn's and give back joy and express gratitude to the app's customer. Whatever, it's not the business of the object implementing `FsprgEmbeddedStoreDelegate`.

And thus processing orders from within the app is complete.
