## Use an Embedded Web Store for Purchases

![The resulting Embedded Web Store within the app](images/20-110-web-store.png)

If you want to let users buy the app from within the app via the _Embedded Web Store_, you'll have to import FastSpring's SDK.

This is additional work, although not very much. Why would you want to do it?

* It is said that embedded stores increase conversion from trial users to paying customers.
* Buying a license from within the app can immediately unlock it. Your application obtains the license from the embedded store.

D> **Philip Goward of Smile**, the team behind TextExpander and PDFpen, stressed that buying a license within the app lowers the barrier to buy the app. Smile has lots of years of experience, so we better listen.
D>
D> The most interesting advice he gave me to share with you is this: display the store window on launch, even on first launch. It converts incredibly well.
D> 
D> I'll certainly have a look at the effect of this change in my own applications. Keep in mind though that having to click through too many dialog boxes on first launch can just as well ruin the initial user experience.

The embedded store SDK provides callbacks to interactions with the FastSpring web store. We're going to upload a different stylesheets so the embedded store looks less ugly. You could even customize it to even better mimic Mac OS X's design, but that'd most likely cause confusion among users because web views just don't behave exactly like regular windows and controls.

We can expect major changes to FastSpring's backend to make working with their service better and interact with an API programmatically in the future. In their new platform, FastSpring provides a client-side JavaScript library backed by RESTful API calls to enable developers to customize many aspects of the shopping and checkout experience.  Native wrappers for these capabilities are planned for 2016, Mike Smith, CTO of FastSpring told me.

Until then, follow these instructions to set up a web view-based embedded store to reap the benefits of purchasing from within the app.

### Enable the Embedded Store in SpringBoard

(Refer to [the docs][doc] for the most up to date instructions.)

The Embedded Web Store will need a different style. The [FastSpring SDK on GitHub][github] contains a folder called "FsprgEmbeddedStoreStyle". Put the CSS, the XHTML, and the PayPal folder into a Zip file. Alternatively, you can use the prepared Zip from the sample code. We'll need that in a moment.

![Enable the web store](images/20-102-enable-web-store.png)

![Create a new store style](images/20-103-create-style.png)

Log into your SpringBoard. From there, apply the following configurations:

* _Store Settings_ / _Advanced_: pick "Property List XML" to enable Web Store requests.
* _Styles_: create a new style. Upload the Zip file you just prepared. 
    * Then _Edit Conditions_ of the style and add an "Order Environment Condition" with the value "FS Embedded" so the default store won't change appearance. 
    * _Activate_ the style afterwards.
* _Store Testing_: select "Simulate Embedded" under _Optional Parameters_ and check out the differences. The embedded style looks much cleaner.

![The default FastSpring style to the left, the embedded style to the right.](images/20-104-stores-comparison.png)

Next, add a test user to test purchases during development.

The _Account_ Page is the calculator button to the right in your SpringBoard. There, navigate to _Users_ (in the sidebar). Add a new user with the "Limited API User" role. You'll receive a password via e-mail.

Keep the e-mail you used for the user and its password handy as you'll likely need it often.

Now everything should be ready to roll from FastSpring's side.

[doc]: https://support.fastspring.com/entries/234307-Embedded-Web-Store-SDK
[github]: https://github.com/FastSpring/FsprgEmbeddedStoreMac#how-to-embed-it

### Embed FastSpring Library

You can use CocoaPods or get the source from GitHub:

* CocoaPods: <https://cocoapods.org/?q=fsprgembeddedstoremac>
* GitHub: <https://github.com/FastSpring/FsprgEmbeddedStoreMac#how-to-embed-it>

I use GitHub for the samples to keep the project set-up simple.

From `FsprgEmbeddedStoreMac/FsprgEmbeddedStore/`, add all the files except the "Test" folder to your project. That will be:

* `FsprgEmbeddedStore.h`
* `FsprgEmbeddedStoreController.h`
* `FsprgEmbeddedStoreController.m`
* `FsprgEmbeddedStoreDelegate.h`
* `FsprgOrderDocumentRepresentation.h`
* `FsprgOrderDocumentRepresentation.m`
* `FsprgOrderView.h`
* `FsprgOrderView.m`
* `FsprgStoreParameters.h`
* `FsprgStoreParameters.m`
* `Model/FsprgFileDownload.h`
* `Model/FsprgFileDownload.m`
* `Model/FsprgFulfillment.h`
* `Model/FsprgFulfillment.m`
* `Model/FsprgLicense.h`
* `Model/FsprgLicense.m`
* `Model/FsprgOrder.h`
* `Model/FsprgOrder.m`
* `Model/FsprgOrderItem.h`
* `Model/FsprgOrderItem.m`

Disable ARC for the 9 files that are left in "Compiler Sources" under the app target's "Build Phases" pane when you filter for "Fsprg". Add the `-fno-objc-arc` flag to all FastSpring-related `.m` files in the list as shown in the screenshot.

![ARC disabled for the FastSpring files files which cause build errors otherwise.](images/20-101-arc-disabled-fastspring-cocoafob.png)

Now the test target may not find the header files by default, though. That seems to be an issue with (some) Swift-only projects, as I didn't have to adjust anything for the Word Counter which is a mostly Objective-C project.

Go to the test target settings and select the "Build Setting" pane. Use the search to get to "User Header Search Paths". In the test target's column, which is probably the second column you can edit, double-click the table cell and drag the `FsprgEmbeddedStore` folder in there (that's the one where we picked the files from).

In the example project setup, this resolves to:

{linenos=off,lang="text"}
    "$(SRCROOT)/../External/FsprgEmbeddedStoreMac/FsprgEmbeddedStore"

Make sure to select "recursive" from the options.

Both the app and test target should build again.

## Implement the Embedded Web Store Protocol

Nearly all of the work will be done in a class which implements `FsprgEmbeddedStoreDelegate`. This protocol has four required methods, only two of which are interesting for most of us:

* `didReceiveOrder(order: FsprgOrder!)`  

    Here, we'll handle automatically unlocking the app after a purchase.
* `viewWithFrame(frame: NSRect, forOrder order: FsprgOrder!) -> NSView!`
    
    Return a custom view to display the order confirmation. This will usually be a thank-you with the license details.
* `didLoadStore(url: NSURL!)`
* `didLoadPage(url: NSURL!, ofType pageType: FsprgPageType)`

D> **Tyler Hall** creates VirtualHostX and he thinks the embedded store is a pretty awful web-view wrapper. It didn't meet his quality standards, so he dropped the embedded store completely when he switched from Stripe to FastSpring. He'd add an embedded store anytime when it can be implemented with native Cocoa controls using a web API.

### Order Confirmation View

It's cool that FastSpring offers showing a custom view after purchases within the store view. It often doesn't look as good because the underlying web view has a white background by default. But you can make a lot from that.

Keeping things clean, I prefer a custom view subclass:

    public class OrderConfirmationView: NSView {
        @IBOutlet public var licenseCodeTextField: NSTextField!
    
        public func displayLicenseCode(_ licenseCode: String) {
            licenseCodeTextField.stringValue = licenseCode
        }
    }
    
It's easy to populate its text field in a custom `StoreController`:

    func view(withFrame frame: NSRect, for order: FsprgOrder!) -> NSView! {
    
        guard  let orderConfirmationView = orderConfirmationView,
            let license = licenseFromOrder(order) 
            else { return nil }
    
        orderConfirmationView.displayLicenseCode(license.licenseCode)
    
        return orderConfirmationView
    }


The result looks like this:

![Our simple view](images/20-301-thankyou.png)

As I said, it's not very pretty. FastSpring's SDK doesn't use Auto Layout, so things look a little bit off by default.

I prefer to leave this alone, return `nil`, close the store window, and show a custom window in `didReceiveOrder(_:)`. There's no need to use all of FastSpring's hooks.

So let's take a look at the more important `didReceiveOrder(_:)` method.

### Unlock the App After Purchases

In `didReceiveOrder(order: FsprgOrder!)`, you'll be able to obtain all license details from `order`. To unlock the app, we need the license code and the licensee's name.

Because your users could buy a different product, more than a single product, or multiple licenses for the same product, we need to check some parameters.

`order.orderItems` contains `FsprgOrderItem`s. Check the item's `productName` to start with the name of the app. If it matches, you've got a paying customer for this particular application.

`FsprgOrderItem` contains `license() -> FsprgLicense`. We can obtain the licensee's name via its `licenseName()` and the license code via `firstLicenseCode()`. With these values, we can build an instance of our own `License` object. The store's job is finished.

In code, there's a lot of implicit unwrapped optionals to steer around. It looks messier than it actually is.

Let me walk you through the process to explain the array transformations:

    func didReceive(order: FsprgOrder!) {
        
        // Thanks Obj-C bridging without nullability annotations:
        // implicit unwrapped optionals are not safe
        if !hasValue(order) {
            return
        }
        
        guard let license = licenseFromOrder(order) 
            else { return }

        storeDelegate?.didPurchaseLicense(license)
    }
    
    private func licenseFromOrder(order: FsprgOrder) -> License? {
        guard let items = order.orderItems() as? [FsprgOrderItem],
            let license = items
                .filter(orderItemIsForThisApp)
                .map(licenseFromOrderItem) // -> [License?]
                .filter(hasValue)          // keep non-nil
                .map({ $0! })              // -> [License]
                .first 
            else { return nil }
    
        return license
    }
    
    private func orderItemIsForThisApp(orderItem: FsprgOrderItem) -> Bool {
        let appName = storeInfo.productName
        
        guard let productName = orderItem.productName() else {
            return false
        }

        return productName.hasPrefix(appName)
    }

    private func licenseFromOrderItem(orderItem: FsprgOrderItem) -> License? {
        guard let orderLicense = orderItem.license(),
            let name = orderLicense.licenseName(),
            let licenseCode = orderLicense.firstLicenseCode() 
            else { return nil }
        
        return License(name: name, licenseCode: licenseCode)
    }

`orderItems()` returns `[AnyObject]!`; we can try to cast the whole array or enumerate the items and cast each on its own. I think this is cleaner, although less lenient if FastSpring should add objects of a different kind.

`license` will be of the value type `License`. To get there from an `FsprgOrderItem`, I apply quite a few array transformations:

1. Filter all order items for this which are about this app, comparing the `productName` as stated above.
2. From the order items which apply, create a `License` instance using the process explained above. This may fail, so we end up with an array of optionals, `[License?]`, which sucks.
3. Filter all elements in the `[License?]` array so only non-nil values are left.
4. Now it's safe to force-unwrap the remaining optionals to get back an array of licenses, `[License]`.
5. Finally, take the first element (if any) and pass it to the delegate.

![Acorn's very sexy registration confirmation window. It's a good idea to go the extra mile and make this pretty](images/20-300-acorn.png)

The delegate may present a window like Acorn's and give back joy and express gratitude to the app's customer. Whatever, it's not the business of the object implementing `FsprgEmbeddedStoreDelegate`.

And thus processing orders from within the app is complete.
