## Using the Clock to Obtain Time

The `TrialPeriod` value object encapsulates both start and end time. And we're able to read and write it to disk via `UserDefaults`. 

A trial shall have a duration of 5 days for this app. To create a `TrialPeriod`, we need the current time as `startDate` and the duration to calculate `endDate`. 

The current time can be obtained using `Date()`, the default constructor. But that's not helping us during tests, which will make the behavior of a whole bunch of service objects hard to verify -- or worse, since nothing can be tested, everything ends up in one big convoluted mess.

Thinking in terms of an expressive domain and testing seams, we need a clock.

    class Clock {
        func now() -> Date {
            return Date()
        }
    }

To make testing a bit more comfortable, I favor a protocol to supply test doubles instead of subclassing `Clock`:

    public protocol KnowsTimeAndDate: class {
        func now() -> Date
    }

    public class Clock: KnowsTimeAndDate {
        public init() { }
    
        public func now() -> Date {
            return Date()
        }
    }

    public class StaticClock: KnowsTimeAndDate {
        let date: Date
    
        public init(clockDate: Date) {
            date = clockDate
        }
    
        public func now() -> Date {
            return date
        }
    }
    

This helps to test `TrialPeriod` creation:

    extension TrialPeriod {
        public init(numberOfDays daysLeft: Days, clock: KnowsTimeAndDate) {
            startDate = clock.now()
            endDate = startDate.addingTimeInterval(daysLeft.timeInterval)
        }
    }

It's trivial to verify that `TrialPeriod(numberOfDays:, clock:)` actually adds the appropriate time interval to the current time in tests:

    class TrialPeriodTests: XCTestCase {

        let clockDouble = TestClock()
        let irrelevantDate = NSDate(timeIntervalSinceNow: 987654321)
    
        func testCreation_WithClock_AddsDaysToCurrentTime() {
        
            let date = NSDate(timeIntervalSinceReferenceDate: 9999)
            clockDouble.testDate = date
            // 10 days
            let expectedDate = date.dateByAddingTimeInterval(10 * 24 * 60 * 60)
        
            let trialPeriod = TrialPeriod(numberOfDays: Days(10), clock: clockDouble)
        
            XCTAssertEqual(trialPeriod.startDate, date)
            XCTAssertEqual(trialPeriod.endDate, expectedDate)
        }
        
        // ...
        
        class TestClock: KnowsTimeAndDate {
            var testDate: Date!
            func now() -> Date {
                return testDate
            }
        }
    }

Backed-up by `KnowsTimeAndDate`, it's easy to adds a few convenience methods on `TrialPeriod`, too, to encapsulate logic related to `TrialPeriod`s right where it belongs:

    extension TrialPeriod {
        public func ended(clock: KnowsTimeAndDate) -> Bool {
            let now = clock.now()
            return endDate < now
        }
    
        public func daysLeft(clock: KnowsTimeAndDate) -> Days {
            let now = clock.now()
            let timeUntil = now.timeIntervalSinceDate(endDate)
            let daysUntil: Double = fabs(Days.amountFromTimeInterval(timeUntil))
        
            return Days(daysUntil)
        }
    }

These two methods are a pain to test if you substitute `clock.now()` with `Date()`: when you run your tests, the date values can be off a second and cause trouble in assertions.

`Days` is just a simple wrapper around double values which helps to calculate seconds (`TimeInterval`) without actually passing meaningless integers around. With Swift's type checking, it then becomes easy to work with durations and enforce validity of the parameters.

    public struct Days {
        public static func timeInterval(amount: Double) -> Double {
            return amount * 60 * 60 * 24
        }
    
        public static func amount(timeInterval: TimeInterval) -> Double {
            return timeInterval / 60 / 60 / 24
        }
    
        public let amount: Double
    
        /// Rounded to the next integer.
        public var userFacingAmount: Int {
        
            return Int(ceil(amount))
        }
    
        public init(timeInterval: TimeInterval) {
            amount = fabs(Days.amount(timeInterval: timeInterval))
        }
    
        public init(_ anAmount: Double) {
            amount = anAmount
        }
    
        public var timeInterval: TimeInterval {
            return Days.timeInterval(amount: amount)
        }
    
        public var isPast: Bool {
            return amount < 0
        }
    }

In my book on application architecture, _Exploring Mac App Development Strategies_, I talk about the benefit of value objects and how to make things testable in more detail. You can find more about that book and value objects [on my website.](http://cleancocoa.com/)

The main lesson I want to uncover is this: try to defer object creation to service objects like the good old Factory object. Especially creation of things you do not own, like `Date` and similar Foundation types. It pays off to not worry about their behavior when you write tests (which you should).

Now that `Days` takes care of encapsulating the main time interval we'll need, and `Clock` to tell the current time, `TrialPeriod` becomes super simple:

    extension TrialPeriod {

        public func ended(clock: KnowsTimeAndDate) -> Bool {
            let now = clock.now()
            return endDate < now
        }

        public func daysLeft(clock: KnowsTimeAndDate) -> Days {
            let now = clock.now()
            let timeUntil = now.timeIntervalSince(endDate)
    
            return Days(timeInterval: timeUntil)
        }
    }
